import { ChatGroq } from "@langchain/groq";
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";

import {StateGraph,MessagesAnnotation } from "@langchain/langgraph";
import {ToolNode } from "@langchain/langgraph/prebuilt";
import { PromptTemplate } from "@langchain/core/prompts";
// import { ai_stock_suggestion_tool } from "./chatBotTools/ai_stock_suggestion.js";
import { Market_news_tool } from "./chatBotTools/market_news.js";
// import { Risk_analysis_tool } from "./chatBotTools/risk_analysis.js";
import  {Portfolio_analysis_tool}  from "./chatBotTools/portfolio_analysis.js";
import { MemorySaver } from "@langchain/langgraph";

import dotenv from "dotenv";
import { ca } from "zod/v4/locales";
dotenv.config();
const checkPointer = new MemorySaver();


//Tool list
const tools = [Portfolio_analysis_tool,Market_news_tool];
const toolNode = new ToolNode(tools);

/** ---------------------------------------------------------LLM initialization------------------------------------------------------------------------------------- */
//initialize main llm for response generation
const llm = new ChatGroq({
    model: "openai/gpt-oss-120b",
    temperature: 0, 
  }).bindTools(tools);
///initialize smaller llm for relevance checking and greeting response
const smallLLm = new ChatGroq({
    model: "llama-3.3-70b-versatile",
    temperature: 0, 
  });

// const llm = new ChatGoogleGenerativeAI({
//     model: "gemini-2.5-pro",
//     temperature: 0, 
//   }).bindTools(tools);  

// const smallLLm = new ChatGoogleGenerativeAI({
//   model : "gemini-2.5-flash",
//   temperature: 0,
// });

/** ---------------------------------------------------------Prompt to check relevance of user query------------------------------------------------------------------------------------- */
// Prompt template for output formatting
const promptForOutputFormatting = PromptTemplate.fromTemplate(`
You are a Financial Report Formatter AI trained to convert raw financial or analytical text into a professionally formatted Markdown report ready for presentation.

Follow the rules below exactly â€” your output must be visually clear, concise, and neatly structured for viewers.

You should generate final output  strictly in Markdown format only.


ðŸª™ Formatting Rules

1. Section Titles

Automatically detect sections (e.g., Overview, Key Metrics, Performance, Analysis, Risks, Conclusion).

Add appropriate emojis to each:

ðŸ“Š Overview / Summary

ðŸ’¡ Key Insights

ðŸ“ˆ Financial Performance

ðŸ” Detailed Analysis

âš ï¸ Risks & Warnings

ðŸ§¾ Conclusion

Make all section titles bold and ensure blank lines before and after.

2. Tables

Convert any data that appears tabular or numeric into clean Markdown tables.

Use headers and alignment properly:

| Metric | Q1 2025 | Q2 2025 | Change |
|--------|----------|----------|---------|
| Revenue | $2.3M | $2.8M | +21% |
| Profit | $450K | $520K | +15% |


Never use tabs or manual spacing.

3. Text Beautification

Bold important financial metrics, company names, or keywords.

Use bullet points or numbered lists for multi-point data or comparisons.

Add blank lines between sections for readability.

Highlight trends or notable metrics using:

Insight: Revenue increased by 12% compared to last quarter.

4. Visual Enhancements

Use --- (horizontal lines) between major sections.

Keep alignment neat and consistent.

Avoid raw numbers without context â€” e.g., use $1.2M (â†‘10% YoY) instead of just 1.2M.

Maintain formal financial tone (no casual phrases).

5. Disclaimer

Always end with the following note:

---
ðŸ§  *This report was generated by AI and may contain inaccuracies. Please verify critical financial data before use.*
*if any html tag is present then convert it into markdown*

6. Output Rules

Return only formatted Markdown â€” no explanations, commentary, or code blocks.

The output must be presentation-ready, balanced, and visually appealing.
`);


// Prompt template to check if user query is finance related, greeting, or non-finance
const promptToCheckRelevance = PromptTemplate.fromTemplate(`
You are a helpful and knowledgeable financial assistant. 
Your job is to classify the user's query into one of the following categories:

1. If the query is a casual greeting (e.g., "hi", "hello", "how are you"), respond only with "greeting".
2. If the query is related to finance, the stock market, portfolios, companies, or investments, respond only with "finance".
3. If the query is unrelated to finance or greetings, respond only with "non-finance".

User Query: {user_query}
`);

// Prompt template for greeting response
const promptToResponsedForGreet = PromptTemplate.fromTemplate(`
You are a friendly and engaging financial assistant. 
When the user sends a greeting, respond with a warm welcome message that encourages them to ask finance-related questions.

User Query: {user_query}
`);

/** ---------------------------------------------------------Graph Nodes/Functions------------------------------------------------------------------------------------- */


//output formatting function
async function formatOutput(state){
  try{
    const reply  = state.messages.at(-1).content;
    const formattedPrompt = await promptForOutputFormatting.format({ text: reply });
    console.log("Formatting output with prompt:", formattedPrompt);
    const res = await llm.invoke([
      { role: "system", content: formattedPrompt },
    ]);
    return res;
  }catch(err){
    return {
      error: true,
      message: "Failed to format output. Please check the logs for details.",
      details: err.message,
    };
  }

}


// Function to call the main LLM for generating responses
async function callModel(state) {
  try{
    console.log("Invoking LLM with state:");
    const reply = await llm.invoke(state.messages);
    return { messages: [...state.messages, reply] };
  }catch(err){
    console.error("Error in callModel:", err);
    return {
      error: true,
      message: "Failed to call model. Please check the logs for details.",
      details: err.message,
    };
  }
}

// default response for non-finance queries
function defaultResponse(state) {
  const userMessage = state.messages.at(-1).content;
  console.log("Non-finance query detected:");
  const reply = {
    role: "assistant",
    content:
      "ðŸ“Š Iâ€™m specialized in finance, stock market, and investment-related topics. Please ask something in that area!",
  };
  return { messages: [...state.messages, reply] };
}
// greeting response function
async function greetingResponse(state) {
  try{
  const userMessage = state.messages.at(-1).content;
  console.log("Greeting detected:", userMessage);
  const formattedPrompt = await promptToResponsedForGreet.format({ user_query: userMessage });
  const res = await smallLLm.invoke([
    { role: "system", content: formattedPrompt },
  ]);

  return { messages: [...state.messages, res] };
}catch(err){
  console.error("Error in greetingResponse:", err);
  return {
    error: true,
    message: "Failed to generate greeting response. Please check the logs for details.",
    details: err.message,
  };
}
}

// function to check user message for finance relevance
async function isRelevant(state) {
  try{
  const userMessage = state.messages.at(-1).content;
  console.log("Checking relevance of user message:", userMessage);
  const formattedPrompt = await promptToCheckRelevance.format({ user_query: userMessage });
  const res = await smallLLm.invoke([
    { role: "system", content: formattedPrompt },
    { role: "user", content: userMessage },
  ]);

  const output = res?.content?.trim().toLowerCase();

  if(output === "greeting") {
    console.log("Message is a greeting.");
    return "greeting";
  }
  if(output === "non-finance") {
    console.log("Message is not finance related.");
    return "default";
  }
  if(output === "finance") {
    console.log("Message is finance related.");
    return "agent";
  }
}catch(err){
    console.error("Error in isRelevant:", err);
    return {
      error: true,
      message: "Failed to determine relevance. Please check the logs for details.",
      details: err.message,
    };
  }
}
  

// function to decide if tools should be used
function shouldUseTools(state) {
  console.log("Inside shouldUseTools with state:", state);
  const lastMessage = state.messages[state.messages.length - 1];
  if(lastMessage.tool_calls && lastMessage.tool_calls.length > 0){
    console.log("Deciding to call tools...",);
    return 'tool_node';
  }
  return "formatOutput";
}

/** ---------------------------------------------------------Workflow Definition------------------------------------------------------------------------------------- */
const workFlow = new StateGraph(MessagesAnnotation)   
      .addNode("agent",callModel)
      .addNode("tool_node",toolNode)
      .addNode("default",defaultResponse)
      .addNode("greeting",greetingResponse)
      .addNode("formatOutput",formatOutput)

      .addConditionalEdges("__start__",isRelevant)
      .addConditionalEdges("agent",shouldUseTools)
      
      .addEdge("greeting","formatOutput")
      .addEdge("default","formatOutput")
      .addEdge("tool_node","agent")
      .addEdge("formatOutput","__end__")


/** ---------------------------------------------------------Compile Workflow------------------------------------------------------------------------------------- */
const app =  workFlow.compile({debug: true ,checkpointer: checkPointer});



export default app;