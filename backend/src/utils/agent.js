import { ChatGroq } from "@langchain/groq";
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import {StateGraph,MessagesAnnotation } from "@langchain/langgraph";
import {ToolNode } from "@langchain/langgraph/prebuilt";
import { PromptTemplate } from "@langchain/core/prompts";
// import { ai_stock_suggestion_tool } from "./chatBotTools/ai_stock_suggestion.js";
import { Market_news_tool } from "./chatBotTools/market_news.js";
import { risk_analysis_tool } from "./chatBotTools/riskAnalysis.js";
import  {Portfolio_analysis_tool}  from "./chatBotTools/portfolio_analysis.js";
import { MemorySaver } from "@langchain/langgraph";

import dotenv from "dotenv";
dotenv.config();
const checkPointer = new MemorySaver();


//Tool list
const tools = [Portfolio_analysis_tool,Market_news_tool,risk_analysis_tool];
const toolNode = new ToolNode(tools);

/** ---------------------------------------------------------LLM initialization------------------------------------------------------------------------------------- */
//initialize main llm for response generation
const llm = new ChatGroq({
    model: "openai/gpt-oss-120b",
    temperature: 0, 
  }).bindTools(tools);
///initialize smaller llm for relevance checking and greeting response
const smallLLm = new ChatGroq({
    model: "llama-3.1-8b-instant",
    temperature: 0, 
  });

// const llm = new ChatGoogleGenerativeAI({
//     model: "gemini-2.5-pro",
//     temperature: 0, 
//   }).bindTools(tools);  

// const smallLLm = new ChatGoogleGenerativeAI({
//   model : "gemini-2.5-flash",
//   temperature: 0,
// });

/** ---------------------------------------------------------Prompt to check relevance of user query------------------------------------------------------------------------------------- */
// Prompt template for output formatting
const promptForOutput = PromptTemplate.fromTemplate(`
You are a Financial Report Formatter AI trained to convert raw financial or analytical text into a professionally formatted Markdown report ready for presentation.

First, greet the user warmly by their name: "Hi {name}," or "Hello {name},"  
Then format the following text into a well-organized financial report:  
{text}

The output format depends on the user's screen width.

---

ü™ô **Formatting Mode Logic**

If **{screenWidth} ‚â• 768**, assume **desktop mode** (large screens).  
If **{screenWidth} < 768**, assume **mobile mode** (small screens).

---

### üñ•Ô∏è Desktop Mode ({screenWidth} ‚â• 768)
For large screens:
- Use Markdown tables for numerical data.
- Keep report sections structured, spaced, and visually rich.
- Use emojis in section titles:
  - üìä Overview / Summary
  - üí° Key Insights
  - üìà Financial Performance
  - üîç Detailed Analysis
  - ‚ö†Ô∏è Risks & Warnings
  - üßæ Conclusion

Example table format:

| Metric | Q1 2025 | Q2 2025 | Change |
|--------|----------|----------|---------|
| Revenue | $2.3M | $2.8M | +21% |
| Profit | $450K | $520K | +15% |

Other rules:
- Use bold text sparingly ‚Äî avoid excessive bold formatting.
- Use bullet lists where comparisons help readability.
- Use "---" between sections.
- Maintain a professional tone.
- Do not use <br> tags or any HTML elements.

---

### üì± Mobile Mode (screenWidth < 768)
For small screens:
- Do not use tables.
- Use vertical stacked data blocks:
  Metric: Revenue  
  Q1 2025: $2.3M  
  Q2 2025: $2.8M  
  Change: +21%

For multiple metrics:
- Revenue: $2.8M (‚Üë21%)  
- Profit: $520K (‚Üë15%)  
- Expenses: $1.1M (‚Üì5%)

Other rules:
- Keep paragraphs short and spaced.
- Use minimal bold text ‚Äî avoid heavy bold formatting.
- Use concise bullet lists for readability.
- Add section emojis as above.
- Keep lines short and mobile-friendly.
- Do not use <br> tags or HTML.

---

### ‚öôÔ∏è Common Rules (Both Modes)

- Detect and format sections automatically.  
- Add blank lines between sections.  
- Highlight trends with natural wording.  
- Convert any HTML tags to Markdown automatically.  
- Maintain a formal financial tone.  
- Avoid using HTML elements and avoid excessive bold text.
- **Do not change, approximate, round, or modify numeric values ‚Äî keep all numbers exactly as provided in the input.**

---

### ‚ö†Ô∏è Disclaimer (Always include)
---
üß† *This report was generated by AI and may contain inaccuracies. Please verify critical financial data before use.*
---

**Output Rules**
- Return only formatted Markdown ‚Äî no explanations or code blocks.
- The result must be presentation-ready and visually clear.
- Apply formatting mode based on this variable: screenWidth = {screenWidth}.
`);





// Prompt template to check if user query is finance related, greeting, or non-finance
const promptToCheckRelevance = PromptTemplate.fromTemplate(`
ou are InsightStox, a highly accurate financial query classifier.

Your task is to classify the user's latest message into one of the three categories below.
Carefully consider context ‚Äî especially if the message is a short command like "repeat", "continue", or "explain more".

Classification Rules:
1. greeting

Use this label if the message is a casual greeting, farewell, or well-being inquiry.
Examples:

"hi", "hello", "good morning", "how are you?", "hey there", "yo", "bye"

2. finance

Use this label if the message:

Mentions stocks, investing, portfolios, companies, markets, crypto, trading, etc.

Requests financial calculations, analysis, metrics, or data

Is a follow-up command referring to a previous finance-related topic
(e.g., "continue", "give example", "calculate it", "explain more", "next step")

3. non-finance

Use this label if the message:

Is not about finance or greetings

Asks about coding, math, schoolwork, health, recipes, AI, personal opinions, etc.

Is a follow-up command referring to a non-finance topic

Output Format:

Respond only with one of the three lowercase words:

greeting
finance
non-finance

No explanation. No extra text.

User Query: {user_query}
`);

// Prompt template for greeting response
const promptToResponsedForGreet = PromptTemplate.fromTemplate(`
You are a friendly and engaging financial assistant. 
When the user with name {name} sends a greeting, respond with a warm welcome message that encourages them to ask finance-related questions.
Message should be concise and professional.add some emojis to make it more engaging.


User Query: {user_query}
`);

/** ---------------------------------------------------------Graph Nodes/Functions------------------------------------------------------------------------------------- */


//output formatting function
async function formatOutput(state){
  try{
    const reply  = state.messages.at(-1).content;
    const userDetails = state.messages.at(0).additional_kwargs?.userDetails || {};
    const userName = userDetails.name || "User";
    const screenWidth = state.messages.at(0).additional_kwargs?.screenWidth || 800;
    console.log("Screen width and user name retrieved:", screenWidth, userName);
    
    const formattedPrompt = await promptForOutput.format({ text: reply ,name: userName || "User",screenWidth:screenWidth});
    console.log("Formatted prompt for output formatting:", formattedPrompt);
    const res = await smallLLm.invoke([
      { role: "system", content: formattedPrompt },
    ]);
    return res;
  }catch(err){
    return {
      error: true,
      message: "Failed to format output. Please check the logs for details.",
      details: err.message,
    };
  }

}


// Function to call the main LLM for generating responses
async function callModel(state) {
  try{
    console.log("Invoking LLM with state:");
    const screenWidth =  state.messages.at(0).additional_kwargs?.screenWidth || 800;
    console.log("User screen width in callModel:", screenWidth);
    let systemMessage = "";
    if (screenWidth < 600) {
  systemMessage =
  `
  You are responding for a mobile device user.

  ‚ö†Ô∏è Never use Markdown tables or multi-column formatting.
  Use stacked key-value lines or bullet lists instead.
  Keep the output compact and readable on small screens.
  --> Don't use br tags or any html elements.
  --> Use bold text sparingly ‚Äî avoid excessive or heavy bold formatting.
  --> Do NOT change, round, approximate, or modify any numerical values.
     All numbers must remain exactly as provided in the input.
  `;
} else {
  systemMessage =
  `
  You are responding for a desktop user.

  You may use Markdown tables for clarity where appropriate.

  --> Use bold text sparingly ‚Äî avoid excessive or heavy bold formatting.
  -->don't use br tags or any html elements.
  --> Do NOT change, round, approximate, or modify any numerical values.
     All numbers must remain exactly as provided in the input.
  `;
}

     const updatedMessages = [
      { role: "system", content: systemMessage },
      ...state.messages,
    ]; 

      const reply = await llm.invoke(updatedMessages);
    return { messages: [...state.messages, reply] };
  }catch(err){
    console.error("Error in callModel:", err);
    return {
      error: true,
      message: "Failed to call model. Please check the logs for details.",
      details: err.message,
    };
  }
}

// default response for non-finance queries
function defaultResponse(state) {
  const userMessage = state.messages.at(-1).content;
  console.log("Non-finance query detected:");
  const reply = {
    role: "assistant",
    content:
      "üìä I‚Äôm specialized in finance, stock market, and investment-related topics. Please ask something in that area!",
  };
  return { messages: [...state.messages, reply] };
}
// greeting response function
async function greetingResponse(state) {
  try{
  const userMessage = state.messages.at(-1).content;
  const userDetails = state.messages.at(0).additional_kwargs?.userDetails || {};
  console.log("Greeting detected: ");
  const formattedPrompt = await promptToResponsedForGreet.format({ user_query: userMessage,name: userDetails.name || "User" });
  const res = await smallLLm.invoke([
    { role: "system", content: formattedPrompt },
  ]);

  return { messages: [...state.messages, res] };
}catch(err){
  console.error("Error in greetingResponse:", err);
  return {
    error: true,
    message: "Failed to generate greeting response. Please check the logs for details.",
    details: err.message,
  };
}
}

// function to check user message for finance relevance
async function isRelevant(state) {
  try{
  const userMessage = state.messages?.at(-1)?.content || "";
  if (!userMessage) {
  console.warn("isRelevant: Missing user message, defaulting to 'default'");
  return "default";
}
  console.log("Checking relevance of user message:");

  const formattedPrompt = await promptToCheckRelevance.format({ user_query: userMessage });
  const res = await smallLLm.invoke([
    { role: "system", content: formattedPrompt },
    { role: "user", content: userMessage },
  ]);

  const output = res?.content?.trim().toLowerCase();
  
  if(output === "greeting") {
    console.log("Message is a greeting.");
    return "greeting";
  }
  else if(output === "finance") {
    console.log("Message is finance related.");
    return "agent";
  }
  else {
    console.log("Message is not finance related.");
    return "default";
  }

}catch(err){
    console.error("Error in isRelevant:", err);
    return "default";
  }
}
  

// function to decide if tools should be used
function shouldUseTools(state) {
  console.log("Inside shouldUseTools with state:");
  const lastMessage = state.messages[state.messages.length - 1];
  if(lastMessage.tool_calls && lastMessage.tool_calls.length > 0){
    console.log("Deciding to call tools...",);
    return 'tool_node';
  }
  return "formatOutput";
}

/** ---------------------------------------------------------Workflow Definition------------------------------------------------------------------------------------- */
const workFlow = new StateGraph(MessagesAnnotation)   
      .addNode("agent",callModel)
      .addNode("tool_node",toolNode)
      .addNode("default",defaultResponse)
      .addNode("greeting",greetingResponse)
      .addNode("formatOutput",formatOutput)

      .addConditionalEdges("__start__",isRelevant)
      .addConditionalEdges("agent",shouldUseTools)
      
      .addEdge("greeting","formatOutput")
      .addEdge("default","formatOutput")
      .addEdge("tool_node","agent")
      .addEdge("formatOutput","__end__")


/** ---------------------------------------------------------Compile Workflow------------------------------------------------------------------------------------- */
const app =  workFlow.compile({debug: true ,checkpointer: checkPointer, maxHistoryMessages: 4});



export default app;